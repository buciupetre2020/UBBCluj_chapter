---
title: "Explorarea Datelor"
format: html
---

## Metode

Întrucât variabilele sondajului sunt în cea mai mare parte variabile nominale, unele putând fiind, întradevăr, considerate ordinale în urma unei recodări, vom alege metode multivariate speciale pentru a analiza aceste date.

1. Analiză factorială exploratorie pe matricea corelațiilor policlorice.
2. FAMD (o extensie a PCA pentru date de tip mixt (nominal/numeric)).
3. Crearea unei metrici/distanțe de similaritate prin metode de învățare automată și folosirea acestei metrici mai departe pentru clusterizare/reducerea dimensionalițătii. 

Ultima variantă este preferabilă opțiunii de a alege o distanță generală precum distanța Gower - des folosită în aceste cazuri cu date de tip mixt. Crearea metricii printr-o metodă (ne)supervizată ca `random forest` este de preferat pentru că fiecare variabilă primește o pondere special adaptată situației, care descrie mai bine structura naturală a datelor din spațiul multidimensional original. În cazul utilizării unei metrici generale, ca distanța Gower, toate variabilele nominale primesc aceeași pondere în scorul final al similarității instanțelor. Metoda automată poate fi folosită în mod nesupervizat cât și supervizat. Vom încerca ambele variante.

### 1. Analiza factorială pe corelații policorice

Prelucrăm datele din formatul `.sav` original într-un tabel. 

```{r}
library(tidyverse)
library(psych)
library(haven)
library(here)
library(survey)
theme_set(hrbrthemes::theme_ipsum_es())

dict <- read_csv(here::here('dict.csv')) |> drop_na()

df <- haven::read_sav(here::here('FES123-2021b.sav'), user_na = TRUE) |>
      mutate(wave = case_when(between(DATAP, as.Date('2021-10-21'), 
                                      as.Date('2021-11-08')) ~ 'W1', 
                              between(DATAP, as.Date('2021-11-09'), 
                                      as.Date('2021-11-23')) ~ 'W2',
                              between(DATAP, as.Date('2021-11-24'), 
                                      as.Date('2021-12-06')) ~ 'W3'))

IDs <- df[,dict[dict$category=='ID', 1,drop=TRUE]]
G <- df[,dict[dict$category=='G', 1, drop=TRUE]]
W1 <- df[df$wave=='W1',dict[dict$category=='W', 1, drop=TRUE]]
W2 <- df[df$wave=='W2',dict[dict$category=='W', 1, drop=TRUE]]
W3 <- df[df$wave=='W3',dict[dict$category=='W', 1, drop=TRUE]]
DEMOG <- df[,dict[dict$category=='DEMOG', 1, drop=TRUE]]

model <- randomForest::randomForest(G |> 
                                    mutate(across(everything(), as.factor)),
                                    proximity=TRUE, mtry=5, 
                                    ntree=1000, nodesize=100)

```

```{r}
library(isotree)
mod <- isotree::isolation.forest(data=G |> mutate(across(everything(), as.factor)), 
                                 ntrees=1000)

distance <- predict(mod, G |> mutate(across(everything(), as.factor)), type='dist')

clust <- cluster::pam(x = 1-distance, k=2, diss = TRUE)
mod <- prcomp(as.matrix(distance), scale=F)
#nu mai pierde timpul, apucă-te și selectează doar economicul și recodeaza variabilele...

```

```{r}


```